---
title: Tim Sort
slug: "/sorting/tim-sort"
---

Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. It was implemented by Tim Peters in 2002 for use in the Python programming language. The algorithm finds subsequences of the data that are already ordered (runs) and uses them to sort the remainder more efficiently. This is done by merging runs until certain criteria are fulfilled. Timsort has been Python's standard sorting algorithm since version 2.3. It is also used to sort arrays of non-primitive type in Java SE 7, on the Android platform, in GNU Octave, on V8, and Swift.

### Complexity

Tim Sort has a *linear* best-case time complexity, which can be tested using a list of identical numbers.

<ComplexityChart title="Time complexity of Tim Sort on a list of identical numbers">
    <ComplexitySeries/>
    <AnalysisSeries id="tim-sort-identical" algorithms={[Algorithms.timSort]} dataSets={[DataSets.zeroes, DataSets.same]}/>
</ComplexityChart>

Tim Sort performs significantly better than *linearithmic* for a variety of sorted lists of numbers.

<ComplexityChart title="Time complexity of Tim Sort on sorted lists of numbers">
    <ComplexitySeries/>
    <AnalysisSeries id="tim-sort-sorted" algorithms={[Algorithms.timSort]} dataSets={[DataSets.sorted, DataSets.reversed, DataSets.square]}/>
</ComplexityChart>

Tim Sort performs about *linearithmic* for a variety of lists of numbers. What these lists have in common is that they contain partially ordered numbers inside them.

<ComplexityChart title="Time complexity of Tim Sort on semi sorted lists of numbers">
    <ComplexitySeries/>
    <AnalysisSeries id="tim-sort-semi-sorted" algorithms={[Algorithms.timSort]} dataSets={[DataSets.sortedHalf, DataSets.halfSorted, DataSets.zigzag, DataSets.semiSorted, DataSets.sawtooth ]}/>
</ComplexityChart>

In the next test, three blended lists are sorted. A blended list is build by combining more than ten different data sets in order to produce a list that is part random, part sorted, part reversed, part zigzag, part zeroes and so on.

<ComplexityChart title="Time complexity of Tim Sort on three blended lists of numbers">
    <ComplexitySeries/>
    <AnalysisSeries id="tim-sort-blended" algorithms={[Algorithms.timSort]} dataSets={DataSets.repeat(DataSets.blender, 3, false)} />
</ComplexityChart>

Finally, Tim Sort has a *linearithmic* worst-case time complexity, which can be tested using a random list of numbers.

<ComplexityChart title="Time complexity of Tim Sort on a random list of numbers">
    <ComplexitySeries/>
    <AnalysisSeries id="tim-sort-random" algorithms={[Algorithms.timSort]} dataSets={[DataSets.random]}/>
</ComplexityChart>

### Algorithm

[Click here](https://github.com/MartinDevillers/omicron/blob/master/src/algorithms/tim-sort.ts) to see the implementation used on this page and [click here](https://github.com/mziccard/node-timsort/blob/master/src/timsort.js) to see the original algorithm it's based on.

